# MCPプロトコル統合要件定義書（再設計版）

## 1. 概要

本文書は、Max/MSP-Claude Desktop間のMCPプロトコル統合に関する要件を再定義するものである。現状の過剰に複雑化した実装を見直し、MCPプロトコルの本質を活かした効率的な設計を採用する。

## 2. 現状の課題

### 2.1 アーキテクチャ上の問題

現状の実装には以下の主要な問題がある：

1. **プロトコル理解の不足**
   - MCPの特性（検証機能、エラー処理）を活用せず、重複した機能を実装
   - プロトコルが本来提供する機能を無視して独自の複雑な層を追加

2. **不必要な複雑さ**
   - JavaScript/C++間の変換層による余計なオーバーヘッド
   - 直接C++で実装可能な部分をJavaScriptで実装
   - OSC通信などによる追加のネットワークレイヤー

3. **非効率なデータフロー**
   - Claude→MCP→JS→OSC→C++→SQLite→C++→OSC→JS→MCP→Claude
   - データ変換と転送による不要なレイテンシとリソース消費

## 3. 要件定義

### 3.1 基本原則

1. **シンプリシティの追求**
   - 不要な抽象化層と変換レイヤーの排除
   - 最短のデータパスの確立

2. **MCPプロトコルの適切な理解と活用**
   - MCPの内部検証機能の活用
   - MCPのエラー処理メカニズムの利用
   - タイムアウト管理の委譲

3. **C++主導のアーキテクチャ**
   - Min-DevKitとの一貫性のあるアプローチ
   - SQLiteへの直接アクセス

### 3.2 機能要件

1. **MCPプロトコル実装**
   - Claude DesktopのMCPプロトコルと適切に連携
   - シンプルなツール定義と実装
   - JSONスキーマによる入力検証の活用

2. **C++データアクセス**
   - SQLiteデータベースへのネイティブアクセス
   - 高速クエリ実行と結果処理
   - メモリ効率の高い実装

3. **Max/MSP操作の最適化**
   - Min-DevKit APIを直接活用した操作
   - 不要な変換の排除

4. **統合テストフレームワーク**
   - MCPプロトコルのモックを活用したテスト
   - エンドツーエンドのワークフロー検証

### 3.3 非機能要件

1. **パフォーマンス**
   - レイテンシ: 操作コマンド実行50ms以内
   - メモリ効率: 50MB以下の常駐メモリ
   - スループット: 1秒間に10以上のコマンド処理

2. **信頼性**
   - エラー回復率95%以上
   - 再接続の自動化
   - 適切なリソース解放

3. **保守性**
   - コードの明確な構造と命名
   - 適切なコメントと文書化
   - モジュール化されたアーキテクチャ

## 4. アーキテクチャ設計

### 4.1 再設計の主なポイント

1. **直接C++実装**
   ```
   +---------------+    MCP     +------------+
   | Claude Desktop|<---------->| C++ Min App|
   +---------------+            +------------+
                                      |
                                      | Direct Access
                                      v
                                +------------+
                                | SQLite DB  |
                                +------------+
   ```

2. **MCPプロトコルツール定義**
   ```javascript
   // シンプルな実装例
   this.mcpServer.registerTool({
     name: 'validateCode',
     inputJsonSchema: { /* スキーマ定義 */ },
     execute: async ({ code, context = '' }) => {
       const result = await validateCode(code, context);
       return { content: JSON.stringify(result) };
     }
   });
   ```

3. **C++ SQLiteアクセス**
   ```cpp
   // ネイティブSQLiteアクセス
   SQLite::Database db("max_knowledge.db");
   SQLite::Statement query(db, "SELECT * FROM max_objects");

   while (query.executeStep()) {
     // 直接結果を処理
   }
   ```

### 4.2 削除対象コンポーネント

1. `max-codegen.js` - 未実装のJavaScript/C++変換レイヤー
2. `node.script max-db-server.js` - Node.js経由のSQL接続
3. 冗長なOSC/ソケット通信レイヤー
4. 独自のタイムアウト処理とリトライロジック

### 4.3 主要コンポーネント

1. **MCP C++サーバー**
   - Claude DesktopのMCPプロトコルと通信
   - ツール実行とレスポンス管理

2. **C++ SQLiteクエリエンジン**
   - データベースアクセスと結果処理
   - キャッシュと最適化

3. **Min-DevKit連携レイヤー**
   - Max/MSP操作の実行
   - イベント処理とステート管理

## 5. 実装ガイドライン

1. **MCPプロトコル活用のベストプラクティス**
   - JSONスキーマを使用した入力検証
   - 適切なエラーレスポンスの返却
   - タイムアウト管理の委譲

2. **C++コーディング規約**
   - モダンC++（C++17以上）の活用
   - スマートポインタによるリソース管理
   - 例外処理の適切な実装

3. **SQLiteパフォーマンス最適化**
   - プリペアドステートメントの使用
   - インデックス最適化
   - トランザクション管理

## 6. 移行計画

1. **フェーズ1: 現状分析と設計** (1週間)
   - 現実装の詳細分析
   - 新アーキテクチャの詳細設計

2. **フェーズ2: C++コア実装** (2週間)
   - MCPサーバーC++実装
   - SQLite直接アクセス実装

3. **フェーズ3: 統合とリファクタリング** (1週間)
   - 不要なコンポーネントの削除
   - エンドツーエンド統合

4. **フェーズ4: テストと最適化** (1週間)
   - 単体・統合テスト実施
   - パフォーマンス測定と最適化

## 7. 参考資料

1. [MCPプロトコル公式仕様](https://github.com/anthropics/anthropic-cookbook/tree/main/model_context_protocol)
2. [Min-DevKit公式ドキュメント](https://cycling74.github.io/min-devkit/)
3. [SQLiteCppライブラリ](https://github.com/SRombauts/SQLiteCpp)
4. [C++17リファレンス](https://en.cppreference.com/w/cpp/17)
