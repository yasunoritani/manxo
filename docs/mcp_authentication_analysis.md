# MCPの認証メカニズム分析レポート

## 1. 基本的な認証アプローチ

MCPプロトコルでは、以下のような認証メカニズムが採用されています：

- **サーバー登録方式**: 主な認証はClaude Desktop設定ファイル内の`mcpServers`セクションへの登録を通じて行われる
- **実行環境ベースの信頼**: 明示的なトークンベースの認証ではなく、ローカル実行環境を前提とした信頼モデル
- **環境変数による構成**: 機密情報や設定値は環境変数として管理される

## 2. 設定ファイル構造

Claude Desktopの`claude_desktop_config.json`ファイルには、以下のような構造でMCPサーバーが登録されます：

```json
{
  "mcpServers": {
    "サーバー名": {
      "command": "実行コマンド",
      "args": ["引数1", "引数2", ...],
      "env": {"環境変数名": "値"}
    }
  }
}
```

例えば、Max 9のMCPサーバーは以下のように登録できます：

```json
{
  "mcpServers": {
    "MaxMCP": {
      "command": "node",
      "args": ["max-mcp-server.js"],
      "env": {
        "MAX_HOST": "127.0.0.1", 
        "MAX_OSC_PORT": "7400",
        "MAX_ACCESS_LEVEL": "full"
      }
    }
  }
}
```

## 3. 環境変数による秘密情報管理

- 機密情報（APIキーなど）は環境変数として設定可能
- 既存の環境変数と新しい値はマージされる（新しい値が優先）
- これにより、認証情報をソースコードに直接含めずに管理できる

## 4. トランスポート層

MCPサーバーは以下のいずれかのトランスポート方式で通信します：

- **stdio** (標準入出力): 主にローカル実行向け。同一プロセス空間での通信に適する
- **sse** (Server-Sent Events): ネットワーク越しの通信に適する

ほとんどの場合、ローカルで実行されるMCPサーバーは`stdio`トランスポートを使用します。

## 5. サーバー登録プロセス

MCP SDKは`update_claude_config`関数を提供しており、以下のような登録プロセスをサポートしています：

1. ファイル指定（Pythonモジュールパス）
2. 必要なパッケージの依存関係指定
3. 環境変数の設定
4. `uv run`コマンドによる実行

## 6. Max 9 MCPサーバーへの応用

Max 9とClaude Desktop間のMCP連携における認証実装には、以下のアプローチが適切です：

### 6.1 環境変数による設定

```json
"env": {
  "MAX_HOST": "127.0.0.1", 
  "MAX_OSC_PORT": "7400",
  "MAX_ACCESS_LEVEL": "full"
}
```

- `MAX_HOST`: Max 9との通信に使用するIPアドレス
- `MAX_OSC_PORT`: OSC通信のポート番号
- `MAX_ACCESS_LEVEL`: 操作の制限レベル（full/restricted/readonly）

### 6.2 セキュリティ考慮事項

- **ローカル実行の前提**: 基本的にはローカルでの実行を前提とするため、複雑な認証は不要
- **コマンドバリデーション**: OSCメッセージには適切なバリデーションを実装し、不正な操作を防止
- **アクセスレベル**: 環境変数で指定されたアクセスレベルに基づいて、使用可能な機能を制限

### 6.3 実装パターン

```
[Claude Desktop] <--MCP登録--> [node.script MCP Server] <--OSC--> [v8ui Bridge]
```

1. node.scriptベースのMCPサーバーをClaude Desktop設定に登録
2. 環境変数から接続情報を読み取り
3. OSC経由でMax 9と通信
4. アクセスレベルに基づいてコマンドをフィルタリング

## 7. 結論

MCPは複雑な認証メカニズムを持たず、基本的にローカルでの実行を前提としています。Max 9との連携においても、環境変数による基本的な設定とアクセスレベルによる保護で十分と考えられます。

セキュリティ要件が高い場合は、OSC通信レベルで追加の認証メカニズム（チャレンジ-レスポンス方式など）を実装することも検討できますが、基本的なユースケースではシンプルな環境変数ベースのアプローチで十分でしょう。
