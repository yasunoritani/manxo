natural_language_intent,min_devkit_function_id,transformation_template,context_requirements
オーディオ入力を作成,1,inlet_in = add_signal_inlet();,オーディオオブジェクト
バングを出力する,2,outlet_bang(m_outlet);,コントロールフロー
数値パラメータを設定,3,param.set(name, value, true);,パラメータオブジェクト
オーディオ処理でサンプル値を取得,4,sample_value = in1[i];,MSPオブジェクト
新しいMaxオブジェクトを定義する,5,class_new(name, constructor, destructor, sizeof(t_myobj), A_GIMME, 0);,オブジェクト作成
属性値を変更する,6,attribute = new_value;,Minオブジェクト
インレットからメッセージを受け取る,7,message<> msg { this, ""message_name"", ""description"", MIN_FUNCTION { /* code */ } };,Minオブジェクト
バッファ参照を作成する,8,buffer_reference buffer { this };,バッファ処理
ディクショナリを操作する,9,auto dict = dict::make();,辞書操作
プリファレンス値を保存する,10,preferences::set(path, key, value);,プリファレンス管理
オーディオシグナルを生成する,11,perform_method(data, channels, frames);,MSPオブジェクト
ユーザーインターフェースを描画する,12,jgraphics_rectangle_fill(g, x, y, width, height, 0);,UIオブジェクト
マルチチャンネルオーディオを処理する,13,mc_perform_method(data, channels, frames);,MCオブジェクト
バッファサンプルにアクセスする,14,float* samples = buffer_locksamples(buffer_obj); /* 処理 */ buffer_unlocksamples(buffer_obj);,バッファ操作
Jitterマトリックスを作成する,15,jit_matrix_info_default(&info); jit_object_method(matrix, _jit_sym_dim, dim);,Jitterオブジェクト
オブジェクトの説明を設定する,16,MIN_DESCRIPTION {""Object description""};,Minオブジェクト
メッセージハンドラーを追加する,17,class_addmethod(c, (method)myobj_bang, ""bang"", 0);,クラス定義
エラーメッセージを表示する,18,object_error((t_object*)x, ""Error message: %s"", error_text);,エラー処理
デバッグ情報を出力する,19,object_post((t_object*)x, ""Debug info: %s"", debug_text);,デバッグ
セーブ・リストア関数を設定する,20,class_addmethod(c, (method)myobj_save, ""save"", A_CANT, 0); class_addmethod(c, (method)myobj_restore, ""restore"", A_GIMME, 0);,状態保存
スレッドセーフな処理を実行する,21,defer_low(x, (method)deferred_function, argument1, argument2);,スレッド安全性
特定時間後に処理を実行する,22,clock_delay(x->clock, milliseconds);,タイミング制御
パッチャーオブジェクトを取得する,23,object_attr_getobj(x, _sym_parentpatcher, (t_object**)&patcher);,パッチャーアクセス
オブジェクト引数を解析する,24,if (argc > 0 && argv[0].a_type == A_FLOAT) { value = atom_getfloat(&argv[0]); },引数処理
シンボルをルックアップする,25,t_symbol* s = gensym(""symbol_name"");,シンボル管理
メモリを確保する,26,void* memory = sysmem_newptr(size);,メモリ管理
メモリを解放する,27,sysmem_freeptr(memory);,メモリ管理
オブジェクトボックスにテキスト表示する,28,object_method(box, _sym_varname, text);,表示制御
サブパッチャーを作成する,29,subpatcher = newobject_sprintf(patcher, ""jpatcher @name %s"", name);,パッチャー作成
リスト要素にアクセスする,30,for (int i=0; i<ac; i++) { value = atom_getfloat(&av[i]); },リスト処理
ディクショナリにエントリを追加する,31,dictionary_appendfloat(dict, key, value);,辞書操作
FFT処理を行う,32,fft_perform(x->fft, in_vector, out_vector, in_spectrum, out_spectrum);,スペクトル処理
MIDI情報を処理する,33,midiin_doread(x, &m);,MIDI処理
マトリックスセルを更新する,34,jit_matrix_set_value(matrix, vector, value);,マトリックス操作
オブジェクトの属性を取得する,35,object_attr_getfloat(x, gensym(""attribute_name""), &value);,属性アクセス
パッチャー内のオブジェクトを検索する,36,object = (t_object*)object_method(patcher, _sym_getnamedbox, name);,オブジェクト検索
UIオブジェクトの外観を設定する,37,attr_args_process(x, argc, argv);,UI設定
Min-APIスタイルのインレットを宣言する,38,inlet<> input { this, ""(signal) Input signal"" };,Min-APIオブジェクト
Min-APIスタイルのアウトレットを宣言する,39,outlet<> output { this, ""(signal) Output signal"" };,Min-APIオブジェクト
Min-APIスタイルの属性を宣言する,40,attribute<number> gain { this, ""gain"", 1.0, range {0.0, 10.0} };,Min-APIオブジェクト
Min-APIスタイルのメッセージハンドラーを宣言する,41,message<> bang { this, ""bang"", ""Process data"", MIN_FUNCTION { /* code */ return {}; } };,Min-APIオブジェクト
Min-APIスタイルの引数を宣言する,42,argument<symbol> name_arg { this, ""name"", ""Name argument"", MIN_ARGUMENT_FUNCTION { name = arg; } };,Min-APIオブジェクト
マルチチャンネルシグナル処理を行う,43,auto audio_bundle = mc_operator_inputs_and_outputs(ENABLE_IN_AND_OUT);,MC操作
バッファからサンプルを読み込む,44,float sample = samples[index];,バッファアクセス
バッファにサンプルを書き込む,45,samples[index] = value;,バッファ書き込み
パフォーマンスカウンターを使用する,46,x->counter = plus_perform(x->counter);,パフォーマンス最適化
オブジェクトのヘルプファイルを設定する,47,class_setname(c, s, classtree_build(s));,ヘルプ設定
オブジェクトアイコンを設定する,48,class_attr_format(c, ""color"", 0, """);,見た目設定
特定のオブジェクトからインスピレーションを得る,49,MIN_RELATED {""object1, object2, object3""};,ドキュメント
パッチャーのコンテキストを取得する,50,atoms info = { patcher.name(), patcher.path() };,コンテキスト情報
オーディオレートでループ処理を行う,51,for (auto i=0; i<n; ++i) { out1[i] = process(in1[i]); },MSP演算
サンプルバッファの長さを取得する,52,long length = buffer_getframecount(buffer_obj);,バッファ情報
バッファのチャンネル数を取得する,53,long channels = buffer_getchannelcount(buffer_obj);,バッファ情報
サンプルレートを取得する,54,double sr = sys_getsr();,システム情報
ブロックサイズを取得する,55,long vs = sys_getblksize();,システム情報
インレット番号を識別する,56,long inlet_number = proxy_getinlet((t_object *)x);,インレット管理
プロキシインレットを作成する,57,x->proxy = proxy_new((t_object *)x, inlet_number, &x->in_val);,インレット管理
内部クロックを作成する,58,x->clock = clock_new(x, (method)myclock_callback);,タイミングオブジェクト
クロックコールバックを実装する,59,void myclock_callback(t_myobj *x) { /* 処理 */ },タイミングコントロール
t_atomを初期化する,60,t_atom a; atom_setlong(&a, value);,原子データ型
アトムリストを作成する,61,t_atom argv[4]; atom_setfloat(&argv[0], 1.0); atom_setsym(&argv[1], ps_name);,データ構造
メッセージを送信する,62,outlet_list(x->outlet, NULL, 2, argv);,メッセージ送信
テキストマッピングを設定する,63,class_register_map_name(c, ps_myclass);,テキスト処理
属性を登録する,64,class_addattr(c, attr_offset_new("myattr", _sym_float64, 0, (method)0, (method)0, calcoffset(t_myobj, f_myattr)));,属性管理
インレット説明テキストを設定する,65,class_addmethod(c, (method)stdinletinfo, "inletinfo", A_CANT, 0);,ドキュメント
標準インレット情報を提供する,66,void stdinletinfo(t_myobj *x, void *b, long a, char *t) { if (a==0) { sprintf(t, "signal/float: Input signal or value"); } },ドキュメント
初期化時にバンドルを構築する,67,for (auto i=0; i < channels; ++i) { add_output("output", "Output channel " + std::to_string(i+1)); },初期化
パラメータ値を遠隔制御する,68,send("mixer/track/1/gain", 0.5);,パラメータ制御
メッセージをパース/解析する,69,const char* text = atom_getsym(argv)->s_name; int param_id = atoi(text);,メッセージ解析
関数ポインタを定義する,70,typedef void (*t_mymethod)(t_myobj *x, t_floatarg f);,関数ポインタ
デフォルト引数を設定する,71,CLASS_ATTR_DEFAULT(c, "limit", 0, "1.0");,属性デフォルト値
UI属性を隠す,72,CLASS_ATTR_INVISIBLE(c, "hidden", 0);,属性表示制御
属性フラグを設定する,73,CLASS_ATTR_SAVE(c, "gain", 0);,属性保存設定
属性スタイルを設定する,74,CLASS_ATTR_STYLE_LABEL(c, "cutoff", 0, "float", "Cutoff Frequency");,属性スタイル
属性フィルタを設定する,75,CLASS_ATTR_FILTER_CLIP(c, "gain", 0.0, 1.0);,属性フィルタ
属性順序を設定する,76,CLASS_ATTR_ORDER(c, "gain", 0, "1");,属性順序
クラスの基本カテゴリを設定する,77,CLASS_ATTR_CATEGORY(c, "Basic");,クラスカテゴリ
テキスト描画にフォントを指定する,78,jfont *font = jfont_create("Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL, 12.0);,グラフィックス
テキストを描画する,79,jgraphics_select_font_face(g, "Arial", JGRAPHICS_FONT_SLANT_NORMAL, JGRAPHICS_FONT_WEIGHT_NORMAL);,グラフィックス
線を描画する,80,jgraphics_move_to(g, x1, y1); jgraphics_line_to(g, x2, y2); jgraphics_stroke(g);,グラフィックス
塗りつぶしの色を設定する,81,jgraphics_set_source_rgba(g, red, green, blue, alpha);,グラフィックス
矩形を描画する,82,jgraphics_rectangle(g, x, y, width, height);,グラフィックス
曲線を描画する,83,jgraphics_curve_to(g, cp1x, cp1y, cp2x, cp2y, x, y);,グラフィックス
円を描画する,84,jgraphics_arc(g, x, y, radius, start_angle, end_angle);,グラフィックス
描画パスを塗りつぶす,85,jgraphics_fill(g);,グラフィックス
パスの輪郭を描画する,86,jgraphics_stroke(g);,グラフィックス
マウスドラッグイベントを処理する,87,void myobj_mousedrag(t_myobj *x, t_object *patcherview, t_pt pt, long modifiers) { /* ドラッグ処理 */ },マウスイベント
マウスダウンイベントを処理する,88,void myobj_mousedown(t_myobj *x, t_object *patcherview, t_pt pt, long modifiers) { /* クリック処理 */ },マウスイベント
マウスアップイベントを処理する,89,void myobj_mouseup(t_myobj *x, t_object *patcherview, t_pt pt, long modifiers) { /* クリック解放処理 */ },マウスイベント
マウスエンターイベントを処理する,90,void myobj_mouseenter(t_myobj *x, t_object *patcherview, t_pt pt, long modifiers) { /* マウス侵入処理 */ },マウスイベント
マウスリーブイベントを処理する,91,void myobj_mouseleave(t_myobj *x, t_object *patcherview, t_pt pt, long modifiers) { /* マウス退出処理 */ },マウスイベント
マウスムーブイベントを処理する,92,void myobj_mousemove(t_myobj *x, t_object *patcherview, t_pt pt, long modifiers) { /* マウス移動処理 */ },マウスイベント
キーボード入力を処理する,93,void myobj_key(t_myobj *x, t_object *patcherview, long keycode, long modifiers, long textcharacter) { /* キー処理 */ },キーボードイベント
オブジェクトの外観を描画する,94,void myobj_paint(t_myobj *x, t_object *view) { t_rect rect; jgraphics *g = (jgraphics*) patcherview_get_jgraphics(view); /* 描画処理 */ },描画イベント
オブジェクトのマウスカーソルを設定する,95,object_method(patcherview, gensym("setcursor"), cursor_type, 0);,UI制御
オブジェクトのサイズを取得する,96,jbox_get_rect_for_view((t_object *)x, patcherview, &rect);,UI情報
オブジェクトのサイズを設定する,97,jbox_set_rect_for_view((t_object *)x, patcherview, &rect);,UI制御
オブジェクトを再描画させる,98,jbox_redraw((t_jbox *)x);,UI更新
オブジェクトのバックグランド色を設定する,99,jrgba color = { red, green, blue, alpha }; object_attr_setjrgba(x, _sym_bgcolor, &color);,UI外観
Minオブジェクトの単位を設定する,100,MIN_UNITS {"Hz", "ms", "dB"};,Minドキュメント
Minオブジェクトのスネークケース名を設定する,101,MIN_TAGS {"fx", "convolution", "filtering"};,Minドキュメント
Minオブジェクトのプロセス関数を実装する,102,sample operator()(sample x) { return x * m_gain; },Min-DSP
Minオブジェクトのセットアップを行う,103,message<> maxclass_setup { this, "maxclass_setup", MIN_FUNCTION { /* 初期化処理 */ return {}; } };,Min-セットアップ
オブジェクトのクレジットを設定する,104,MIN_AUTHOR {""Cycling '74""};,Min-ドキュメント
信号対信号演算を実装する,105,template <typename T> sample operator()(sample x, T y) { return x * y; },Min-DSP演算
バッファデータの読み込みを実装する,106,dictobj::for_each(my_dict, [&](const symbol& key, atom& value) { /* 処理 */ });,Min-辞書処理
Min-APIスタイルのバッファ参照を作成する,107,buffer_reference my_buffer { this };,Min-バッファ
Min-APIスタイルのバッファビュー取得,108,auto buf = buffer.get();,Min-バッファ
Min-APIスタイルのバッファをロック,109,auto b = buffer.lock();,Min-バッファ
Minオブジェクトの範囲パラメータを設定,110,range {0.0, 100.0},Min-パラメータ
Minオブジェクトのユニット表示を設定,111,title {"Frequency"}, description {"Cutoff frequency"}, unit {"Hz"},Min-パラメータ
Minオブジェクトのラベル表示を設定,112,title {"Amount"}, range {0.0, 1.0, 0.5},Min-パラメータ
Min-APIスタイルの限定範囲属性,113,attribute<number, threadsafe::no, limit::clamp> gain { this, "gain", 0.5, range {0.0, 1.0} };,Min-属性
Min-APIスタイルのクリップなし属性,114,attribute<number, threadsafe::no, limit::none> amount { this, "amount", 0.5 };,Min-属性
Min-APIスタイルのスレッドセーフ属性,115,attribute<number, threadsafe::yes> feedback { this, "feedback", 0.5, range {0.0, 0.99} };,Min-属性
Min-APIスタイルのシンボル属性,116,attribute<symbol> mode { this, "mode", "linear" };,Min-属性
Min-APIスタイルのブール属性,117,attribute<bool> bypass { this, "bypass", false };,Min-属性
ディクショナリをパースする,118,dict d = dict(args); auto value = d["key"];,Min-辞書
Minオブジェクトからシンボルを出力,119,output[0].send(symbol(text));,Min-出力
Minオブジェクトからリストを出力,120,output[0].send({1.0, 2.0, 3.0, "text"});,Min-出力
Minオブジェクトからバングを出力,121,output[0].send(k_sym_bang);,Min-出力
自己送信メッセージを処理,122,message<> trigger { this, "trigger", "Trigger internal processing", MIN_FUNCTION { this->bang(); return {}; } };,Min-メッセージ
引数に基づいてパラメータを初期化,123,MIN_ARGUMENT_FUNCTION { gain = arg; },Min-引数
ビューを実装する,124,ui<> ui_handler { this, MIN_FUNCTION { /* UI処理 */ return true; }};,Min-UI
座標マッピングを実装する,125,double map_value(double value, double in_low, double in_high, double out_low, double out_high) { return ((value - in_low) / (in_high - in_low)) * (out_high - out_low) + out_low; },ユーティリティ
バッファデータを正規化する,126,for (auto i=0; i<length; ++i) { samples[i] /= max_value; },バッファ処理
ピーク値を検出する,127,float peak = 0.0f; for (auto i=0; i<length; ++i) { peak = std::max(peak, std::abs(samples[i])); },シグナル処理
RMS値を計算する,128,float sum = 0.0f; for (auto i=0; i<length; ++i) { sum += samples[i] * samples[i]; } float rms = sqrt(sum / length);,シグナル分析
周波数から角速度に変換する,129,double omega = 2.0 * M_PI * frequency / sampling_rate;,DSP変換
バイリニア変換を適用する,130,double c = 1.0 / tan(omega / 2.0);,フィルター設計
ディレイラインを更新する,131,delay_line[write_index] = input; write_index = (write_index + 1) % delay_length;,オーディオ遅延
ディレイラインから読み込む,132,float delayed_sample = delay_line[(write_index - delay_samples + delay_length) % delay_length];,オーディオ遅延
パッチャー内のオブジェクトにメッセージを送信する,133,object_method_typed(target_object, message_name, argc, argv, nullptr);,オブジェクト間通信
有効な値かどうか確認する,134,if (!std::isnan(value) && !std::isinf(value)) { /* 処理 */ },値検証
マトリックスの次元情報を設定する,135,jit_matrix_info_set_dim(&info, 2, dim);,Jitter設定
マトリックスの型情報を設定する,136,info.type = _jit_sym_char;,Jitter設定
Jitterマトリックスのメモリをロックする,137,jit_object_method(matrix, _jit_sym_getdata, &data);,Jitterデータアクセス
Jitterマトリックスのメモリロックを解除する,138,jit_object_method(matrix, _jit_sym_lock, 0);,Jitterデータアクセス
OpenGLリソースを初期化する,139,jit_gl_context ctx = jit_gl_get_context();,Jitter-GL
シェーダーをロードする,140,jit_object_method(shader, _jit_sym_load, shader_path, 0, 0);,Jitter-GL
テクスチャを生成する,141,texture = (t_jit_object *)jit_object_new(_jit_sym_jit_gl_texture, context);,Jitter-GL
OpenGLシェーダーを適用する,142,jit_object_method(shader, _jit_sym_begin);,Jitter-GL
3Dオブジェクトを描画する,143,draw_box(1.0, 1.0, 1.0);,Jitter-GL
カメラ位置を設定する,144,jit_object_method(camera, _jit_sym_position, position[0], position[1], position[2]);,Jitter-GL
オブジェクトの回転を設定する,145,jit_object_method(object, _jit_sym_rotatexyz, rotate_x, rotate_y, rotate_z);,Jitter-GL
オブジェクトの位置を設定する,146,jit_object_method(object, _jit_sym_position, pos_x, pos_y, pos_z);,Jitter-GL
オブジェクトのスケールを設定する,147,jit_object_method(object, _jit_sym_scale, scale_x, scale_y, scale_z);,Jitter-GL
OpenGLコンテキストをバインドする,148,jit_object_method(draw_context, _jit_sym_bind);,Jitter-GL
マトリックスフィールドアクセスを取得する,149,auto field = jit_object_method(matrix, _jit_sym_getfieldbyname, "position");,Jitter-データ
パーティクルシステムを更新する,150,jit_object_method(system, _jit_sym_update);,Jitter-物理
物理世界をシミュレーションする,151,jit_object_method(world, _jit_sym_simulate, time_step);,Jitter-物理
メッシュデータを生成する,152,jit_object_method(mesh, _jit_sym_rebuild);,Jitter-メッシュ
画像をファイルに保存する,153,jit_object_method(matrix, _jit_sym_write, "image.png");,Jitter-ファイル
画像をファイルから読み込む,154,jit_object_method(matrix, _jit_sym_read, "image.png");,Jitter-ファイル
バイナリデータを読み込む,155,sysfile_readtextfile(filename, &txthandle, 0);,ファイル操作
バイナリデータを書き込む,156,sysfile_writetextfile(filename, txthandle, &etype);,ファイル操作
ファイルダイアログを表示する,157,open_dialog(x, filename, MAX_PATH_CHARS, &path_id, &type_id, &type_count);,ファイルUI
オブジェクトのコンテンツを永続化する,158,binbuf_write(x->binbuf, filename, path, 0);,オブジェクト永続化
バイナリバッファにメッセージを追加する,159,binbuf_append(x->binbuf, a_binbuf);,バイナリデータ
バイナリバッファからメッセージを取得する,160,binbuf_getnatom(x->binbuf);,バイナリデータ