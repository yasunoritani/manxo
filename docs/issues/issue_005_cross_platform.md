# Issue #005: クロスプラットフォーム実装基盤

## 概要

**優先度**: 高
**工数見積**: 3-5週間（他のIssueと並行）
**担当者推奨**: OS固有API・ビルドシステム経験者

v8uiプロジェクトがMac/Windows両プラットフォームで動作するための基盤実装。初期設計段階からクロスプラットフォーム対応を考慮し、後付け対応によるリファクタリングコストを削減する。

## 目標

1. Mac/Windows両プラットフォームで一貫した動作を実現する抽象化レイヤーの構築
2. クロスプラットフォームビルド環境の整備と自動化
3. OS固有コードの適切な分離と管理
4. 継続的なクロスプラットフォームテスト環境の構築

## 技術的課題

### OS固有APIの差異

- **ファイルシステムアクセス**: パス区切り文字、権限モデルの違い
- **プロセス間通信**: パイプ、共有メモリなどの実装差異
- **スレッディング**: Win32 APIとPOSIXスレッドの違い
- **ダイナミックライブラリ**: DLLと.dylib/.frameworkの違い

### 依存ライブラリの互換性

- **libwebsockets**: クロスプラットフォームビルドと統合
- **oscpack**: Windows/Mac両対応の確認と最適化
- **Min-DevKit**: OS固有の差異の抽象化

### C++固有の問題

- **ABI互換性**: コンパイラ間のABI差異への対応
- **STL実装差異**: 標準ライブラリ実装の違いへの対応
- **C++17機能**: filesystem等の機能のクロスプラットフォーム対応

## 実装項目

### 1. プラットフォーム抽象化レイヤー

```cpp
// platform.h - 抽象化レイヤーの例
namespace v8ui {
namespace platform {

// ファイルシステム抽象化
std::string GetExecutablePath();
std::string CombinePath(const std::string& base, const std::string& relative);
bool FileExists(const std::string& path);

// スレッディング抽象化
class Thread {
public:
    using ThreadFunction = std::function<void()>;
    static Thread Create(ThreadFunction func);
    void Join();
    // ...
};

// ダイナミックライブラリロード抽象化
class DynamicLibrary {
public:
    static std::unique_ptr<DynamicLibrary> Load(const std::string& path);
    void* GetSymbol(const std::string& name);
    // ...
};

// ...

} // namespace platform
} // namespace v8ui
```

### 2. ビルドシステム整備

1. **CMakeのクロスプラットフォーム対応強化**
   - プラットフォーム固有の条件分岐の整理
   - 依存ライブラリの検出と設定の共通化
   - ビルドターゲットの統一化

2. **依存ライブラリのビルド自動化**
   - Windows/Mac両対応のビルドスクリプト
   - 依存バージョンの明示化と固定
   - バイナリ互換性の確保

3. **CI/CD環境の構築**
   - GitHub ActionsでのWindows/Macマトリクスビルド
   - クロスプラットフォームテストの自動化
   - ビルド成果物の検証と比較

### 3. Min-DevKit連携の抽象化

1. **Max/MSPオブジェクトモデルのOS差異吸収**
   - プラットフォーム固有APIの抽象化
   - パス処理の統一
   - リソースアクセスの共通化

2. **プラグイン形式の差異対応**
   - Windows: .dll
   - Mac: .mxo bundle
   - バイナリフォーマットの適切な生成

### 4. テスト・検証基盤

1. **クロスプラットフォームテストフレームワーク**
   - 両プラットフォームでの自動テスト
   - プラットフォーム固有バグの検出

2. **パフォーマンス検証**
   - プラットフォーム間のパフォーマンス差異測定
   - ボトルネックの特定と最適化

## タスク分解と工数

| No | タスク | 詳細 | 工数(日) |
|----|--------|------|----------|
| 1 | プラットフォーム抽象化設計 | 抽象化レイヤーの設計とインターフェース定義 | 2-3 |
| 2 | ファイルシステム抽象化実装 | パス操作、ファイルI/O、リソースアクセス | 2-3 |
| 3 | スレッディング抽象化実装 | スレッド生成、同期プリミティブ、シグナル | 3-4 |
| 4 | ダイナミックライブラリ抽象化 | ライブラリロード、シンボル解決 | 1-2 |
| 5 | CMakeビルドシステム整備 | クロスプラットフォームビルド設定 | 3-4 |
| 6 | 依存ライブラリビルド自動化 | libwebsockets, oscpackのビルド統合 | 2-3 |
| 7 | Min-DevKit連携抽象化 | Max/MSP APIアクセスの共通化 | 3-4 |
| 8 | テスト環境構築 | 自動テスト基盤の構築 | 2 |
| 9 | Windows固有実装テスト | Windows環境での検証 | 2-3 |
| 10 | Mac固有実装テスト | Mac環境での検証 | 2-3 |

**合計工数**: 20-29人日（約3-5週間）

## 他Issueとの依存関係

- **#002（プロジェクト構造再設計）との密接な連携**
  - ディレクトリ構造をクロスプラットフォーム考慮で設計
  - プラットフォーム固有コードの配置規則の統一

- **#001（Min-DevKit/Claude連携）への影響**
  - API抽象化レイヤー経由でのMax/MSPアクセス

- **#003（WebSocketクライアント）への影響**
  - ソケット通信のクロスプラットフォーム処理

## 成果物

1. **プラットフォーム抽象化ライブラリ**
   - `src/core/platform/` ディレクトリ
   - `platform.h`, `platform_win.cpp`, `platform_mac.cpp`

2. **クロスプラットフォームビルド設定**
   - 更新されたCMake設定
   - ビルド自動化スクリプト

3. **クロスプラットフォームテスト**
   - Windows/Mac検証済みのテストケース
   - CI/CD設定

## 完了基準

1. Windows/Mac両プラットフォームでビルドが成功すること
2. 基本機能が両プラットフォームで一貫して動作すること
3. プラットフォーム固有コードがすべて抽象化レイヤーの背後に隠蔽されていること
4. CI/CDパイプラインで自動テストが継続的に実行されること

## リスクと軽減策

| リスク | 影響度 | 可能性 | 軽減策 |
|--------|--------|--------|--------|
| 予期せぬプラットフォーム差異 | 高 | 中 | 早期のプロトタイピングとテスト |
| 依存ライブラリの互換性問題 | 高 | 中 | 特定バージョンの固定と事前検証 |
| パフォーマンス差異 | 中 | 高 | プラットフォーム固有の最適化 |
| テスト環境の複雑化 | 中 | 中 | CI/CD自動化による継続的検証 |
