pythonナレッジ

numpy,pandasを積極的に使うべき。

SQLiteの使用も視野に入れるべき。

if/elifを辞書に置き換えるべき。条件に応じて異なる処理を行う場合、辞書を使用することでコードを簡潔にできる。  
   
戦略パターンを使うべき。条件に応じた処理をクラスに分けることで再利用性が向上する。  
   
リスト内包表記を使うべき。リストや辞書の生成をfor文で行っている場合、リスト内包表記で短縮可能。  
   
mapやfilterを使うべき。関数型プログラミングを取り入れることでコードが簡潔になる。  
   
ジェネレータを使うべき。大量データを扱う場合、ジェネレータ式を使うことでメモリ効率が向上する。  
   
マルチスレッドやマルチプロセスを使うべき。I/Oバウンドにはスレッド、CPUバウンドにはプロセスを使用する。  
   
@lru_cacheを使うべき。繰り返し計算される値をキャッシュして再計算を避ける。  
   
numpyを使うべき。ベクトル演算にnumpyを使えば数値計算を高速化できる。  
   
setやdictを使うべき。リストで探索している場合、setやdictを使うことで探索が高速化する。  
   
dataclassを使うべき。@dataclassを使えばinitやreprを自動生成できる。  
   
itertoolsを使うべき。組み合わせや順列の生成を効率的に行える。  
   
デコレータを使って共通処理をまとめるべき。前後処理をデコレータで共通化することでコードが簡潔になる。  
   
enumerateを使うべき。インデックス付きでループを回す場合、range(len())よりも簡潔にできる。  
   
zipを使うべき。複数のリストを同時にループ処理する際にコードが短くなる。  
   
getattrを使うべき。オブジェクトのメソッドを文字列から動的に呼び出せる。  
   
with文を使うべき。ファイルの読み書きやロック処理を自動的に管理できる。  
   
デフォルト引数を使うべき。デフォルト値を引数に直接設定することでコードを簡潔にできる。  
   
f-stringを使うべき。文字列フォーマットを簡潔に記述できる。  
   
setdefaultを使うべき。辞書の初期値をif文なしで直接設定できる。  
   
loggingを使うべき。デバッグにprintではなくloggingを使うことで出力制御が容易になる。  
   
in演算子を使うべき。要素の存在確認をfor文でなくinで行うことで簡潔にできる。  
   
sortedのkeyを使うべき。カスタマイズしたソートを簡単に行える。  
   
クラスメソッドを@classmethodで定義すべき。インスタンスを生成せずにクラスメソッドを使用できる。  
   
オーバーロードを使うべき。異なる引数パターンを@overloadで処理可能にする。  
   
or演算子を使ってNoneをデフォルト値にするべき。Noneチェックをif文でなくor演算子で行える。  
   
ビット演算を使うべき。整数の偶数・奇数判定や2の累乗判定を効率的に行える。  
   
デフォルト引数にミュータブルな値を使用しないべき。リストや辞書はNoneを使って初期化する。  
   
ラムダ式を使うべき。簡単な関数を定義する場合、ラムダ式でコードを短くできる。  
   
ガード節を使うべき。不要なif/elseを省略してコードを読みやすくする。  
   
リストや辞書をコピーする場合はcopy()を使うべき。代入でなくcopyを使うことで参照コピーを避けられる。  
   
文字列の結合には+ではなくjoinを使うべき。文字列を連結する場合、+演算子よりも効率的。  
   
ファイルの読み込みにはreadlines()ではなくイテレータを使うべき。メモリ使用量を削減できる。  
   
再帰を可能な限り避けるべき。ループに置き換えることでスタックオーバーフローを防げる。  
   
末尾再帰にすべき。可能ならば末尾再帰にすることでコードの読みやすさが向上する。  
   
sorted()とsort()の違いを理解すべき。sorted()は新しいリスト、sort()はインプレースで並び替える。  
   
例外処理は必要最小限にすべき。エラーの原因を特定しやすくなる。  
   
オブジェクトのソートには__lt__を定義すべき。sort()やsorted()が自動で使える。  
   
データを変更不可にしたい場合はtupleを使うべき。リストでなくtupleにすればイミュータブルになる。  
   
コマンドライン引数はargparseを使うべき。引数処理が容易になる。  
   
比較演算子には==を使うべき。オブジェクトの同一性ではなく値の比較には==を使用する。  
   
リストの長さを比較する場合はbool()を使わずに直接if文に渡すべき。bool()は冗長になる。  
   
from importを使うべき。モジュール全体をimportするよりもメモリ消費を抑えられる。  
   
リストの中身が重複しない場合はsetを使うべき。リストよりも探索が高速になる。  
   
for文の中で定数を再計算しないべき。定数はループの外で定義することで効率が良くなる。  
   
整数の累乗にはmath.pow()よりも**を使うべき。**の方がパフォーマンスが良い。  
   
辞書のキーやリストのインデックスアクセスをtry-exceptでラップしないべき。in演算子で確認してからアクセスすべき。  
   
リスト内包表記はfor文よりも高速な場合が多いため、可能な限りリスト内包表記を使うべき。  
   
ジェネレータの要素をlist()で強制展開しないべき。必要なデータ量だけ生成すべき。  
   
import *は避けるべき。名前空間が汚染されるため、特定の関数やクラスを指定してimportするべき。  
   
ソート済みデータを探索する場合はbisectを使うべき。線形探索よりも高速に探索できる。  
   
dequeを使うべき。キューやスタックを実装する場合はlistではなくdequeを使うと効率的。  
   
assert文はデバッグ用にとどめるべき。実行時エラーハンドリングにはtry-exceptを使うべき。  
   
正規表現のコンパイルは事前に行うべき。re.compile()を使うことで繰り返し使用時のパフォーマンスが向上する。  
   
deepcopyは必要最小限に使うべき。deepcopyは通常のcopyよりも遅いため、可能ならcopyを使用する。

